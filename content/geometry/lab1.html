<!DOCTYPE html>
<html lang="en">

<head>
	<title>Discrete Curvatures and Normals</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="stylesheet" href="../style/main.css">
</head>

<body>
  <div id="students">
  <select onchange="load_students()" id="group">
    <option value="---">Группа</option>
    <option value="595">595</option>
    <option value="599">599</option>
  </select>
  <select onchange="load_task()" id="surname" disabled>
    <option value="---">Фамилия Имя</option>
  </select>
    <input name="hide_task" value="Спрятать задание" onclick="toggleTask();" type="button"> 
  </div>

   <div id="functions">
    <div> 
      <span id="paramx"> x = ( 2+cos(u))*cos(v)</span> <br/>
      <span id="paramy"> y = ( 2+cos(u))*sin(v)</span> <br/>
      <span id="paramz"> z = sin(u) </span>
    </div>
    <textarea id="terminal" name="terminal" rows="6" cols="80" style="width:100%;margin-bottom:-5px;">
jacobian = [ d(x, [u,v]), d(y, [u,v]), d(z, [u,v]) ]
q = jacobian[1][1]
f = d(q, u)</textarea>
   <div> f=  <span id="colorfunc"> u+v </span> </div>
    <input name="execute" value="Пересчитать функцию цвета f" onclick="execute();" type="button"> 
    <input name="execute" value="Перекрасить поверхность" onclick="updatePlot();" type="button"> 
   </div>
    
   <div id="explanation">
   <h3> Здесь будет задание.</h3>
   </div>
    
    
	<div id="info">
		<input type="file" id="fileInput" style="visibility:hidden">
	</div>
	<div id="info"  style="visibility:hidden">
		<h2>Discrete Curvatures and Normals</h2>
		<div id="meta">Loading...</div>
	</div>
	<div id="logo">
		<a href="https://geometrycollective.github.io/geometry-processing-js/" target="_blank">
			<img src="../imgs/logo.png" width="80" height="80" border="0">
		</a>
	</div>
	
	
	<script type="text/javascript">
	
var students = {595:[
"Воробьев Даниил",
"Егоров Евгений",
"Жернов Андрей",
"Исламов Искандер",
"Козлова Надежда",
"Комаров Михаил",
"Крохалев Арсений",
"Литвинов Станислав",
"Машурин Владислав",
"Мингалиев Наиль",
"Моисеев Федор",
"Поконечный Эдуард",
"Рубаненко Евгений",
"Сигарева Ирина",
"Смирнова Елена",
"Шаруев Дмитрий"
],599:[
"Богданов Семён",
"Васильчишин Сергей",
"Гребенщикова Елизавета",
"Козлов Александр",
"Куприянов Артём",
"Левашев Владислав",
"Лернер Регина",
"Марков Александр",
"Мартинсон Михаил",
"Муравьёв Кирилл",
"Нарсия Давид",
"Нифантова Ирина",
"Пыркин Дмитрий",
"Ремизова Анастасия",
"Сергунин Андрей",
"Степанов Илья",
"Топильский Артём",
"Якушева Софья"
]}

	 function toggleTask() {	 
      $('#explanation').toggleClass('hidden');
      $('#functions').toggleClass('hidden');
      $('#students input').val($('#explanation').hasClass('hidden') ? "Показать задание" :"Спрятать задание");
	 }

	 function load_students() {	 
	 var surnameList = $('#surname');
	 surnameList.children().each(function() {if (this.value != '---') this.remove();});
	 //surnameList.append(firstentry);
	 
	 let group = $("#group option:selected").html();
	 if (group== 'Группа') {
    surnameList.prop( "disabled", true );
	  return;
	 }
	 
   $.each(students[group], function(i,v)
    {
    var li = $('<option></option>').html(v).attr('value', v)
    //console.log(li.html());
        li.appendTo(surnameList);
    });
    surnameList.prop( "disabled", false );
	 }
	
	function hashCode(str) {
  return Math.abs(str.split('').reduce((prevHash, currVal) =>
    ((prevHash << 5) - prevHash) + currVal.charCodeAt(0), 0));
  }

	 function load_task() {	 
	 let hashstring = $('#group option:selected').html()+ $('#surname option:selected').html();
	 let hash = hashCode(hashstring);
	 surface_num = Math.abs((hash >> 6) % surfaces.length);
	 colorfunc_num = (hash % 64) % 10;
	 console.log(hashstring + ' hash ' + hash + ' surface ' + surface_num + ' func ' + colorfunc_num);
	 $('#paramx').html('x = '+ surfaces[surface_num]['x']);
	 $('#paramy').html('y = '+ surfaces[surface_num]['y']);
	 $('#paramz').html('z = '+ surfaces[surface_num]['z']);
  	initMesh();	 
	 }
	</script>

<script src="../algebrite/jquery.min.js"></script>
<script src="../algebrite/algebrite.bundle-for-browser.js"></script>

	<script type="text/javascript">//&#x25B6;
	    function execute () {
        try {
          var textToBeExecuted = $('#terminal').val();
          var result;
          if (/Algebrite\.[a-z]/.test(textToBeExecuted) || /;[ \t]*$/.test(textToBeExecuted)) {
            result = eval(textToBeExecuted);
          }
          else {
            Algebrite.run($('#paramx').html());
            Algebrite.run($('#paramy').html());
            Algebrite.run($('#paramz').html());
            result = Algebrite.run(textToBeExecuted);
          }
          console.log(result);
          $('#colorfunc').html(Algebrite.run('f'));
        }
        catch (err) {
          var errDesc = err;
          $('#colorfunc').html('<h4>Error!<\/h4><code>' + errDesc + '<\/code>')
        }
    }    
	</script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/87/three.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.5/dat.gui.min.js"></script>
	<script src="../libs/detector.js"></script>
	<script src="../libs/trackball-controls.js"></script>
	<script src="../linear-algebra/vector.js"></script>
	<script src="../core/vertex.js"></script>
	<script src="../core/edge.js"></script>
	<script src="../core/face.js"></script>
	<script src="../core/halfedge.js"></script>
	<script src="../core/corner.js"></script>
	<script src="../core/mesh.js"></script>
	<script src="../core/geometry.js"></script>
	<script src="../utils/meshio.js"></script>
	<script src="../utils/colormap.js"></script>
	<script src="../parser.js"></script>
	<script>
  var colorfunc = (f, u, v) => { 
  let fu = f.replace(/\bu\b/g, '('+u.toString()+')');
  let fuv = fu.replace(/\bv\b/g, '('+v.toString()+')');
  //console.log(fuv);
  return parseFloat(Algebrite.float(fuv));} <!--  (Math.cos(u)*Math.sin(v))/1 -->


var surface_num = 0;
var surfaces = [{ // from K3DSurf
       x : "(2+cos(u))*cos(v)",
       y : "(2+cos(u))*sin(v)",
       z : "sin(u)",
       umin : 0,
       umax : 2*Math.PI,
       unum : 50,
       vmin : 0,
       vmax : 2*Math.PI,
       vnum : 50,
       name : 'torus',
},{
       x : "cos(u) / (sqrt(2) + sin(v))",
       y : "1 / (sqrt(2) + cos(v))",
       z : "sin(u) / (sqrt(2) + sin(v))",
       umin : 0,
       umax : 2*Math.PI,
       unum : 50,
       vmin : 0,
       vmax : 2*Math.PI,
       vnum : 50,
       name : 'limpet_torus',
},{
       x : " cos(u)*cos(v)+sin((sin(u)+1)*2*PI) ",
       y : " 4*sin(u) ",
       z : "cos(u)*sin(v)+cos((sin(u)+1)*2*PI) ",
       umin : -Math.PI/2,
       umax : Math.PI/2,
       unum : 50,
       vmin : 0,
       vmax : 2*Math.PI,
       vnum : 50,
       name : 'pseudosphere',
},{
       x : "cos(u)*cos(v)*sin(u)",
       y : "sin(u)*sin(v)*sin(u)",
       z : "sin(u)*sin(v)*cos(u)",
       umin : -Math.PI/2,
       umax : 0,
       unum : 50,
       vmin : 0,
       vmax : 2*Math.PI,
       vnum : 50,
       name : 'sphere_7',
},{
       x : "cos(u)*cos(v)",
       y : "sin(u)*sin(v)*cos(v)",
       z : "cos(u)*sin(v)",
       umin : -Math.PI/2,
       umax : Math.PI/2,
       unum : 50,
       vmin : 0,
       vmax : 2*Math.PI,
       vnum : 50,
       name : 'sphere_3',
},{
       x : "cos(u)*sin(2*v)",
       y : "sin(v)",
       z : "sin(u)*sin(2*v)",
       umin : 0,
       umax : 2*Math.PI,
       unum : 50,
       vmin : -Math.PI/2,
       vmax : Math.PI/2,
       vnum : 50,
       name : 'eight',
},{
       x : "cos(u) *(3  *cos(v) - cos(3  *v))",
       y : "3  *sin(v) - sin(3 * v)",
       z : "sin(u)  *(3  *cos(v) - cos(3 * v))",
       umin : 0,
       umax : 2*Math.PI,
       unum : 50,
       vmin : -Math.PI/2,
       vmax : Math.PI/2,
       vnum : 50,
       name : 'kidney',
},{
       x : "sin(u) / (sqrt(2) + cos(v))",
       y : "cos(u-2*PI/3) / (sqrt(2) + cos(v-2*PI/3))",
       z : "sin(u+2*PI/3) / (sqrt(2) + cos(v+2*PI/3))",
       umin : -Math.PI,
       umax : Math.PI,
       unum : 50,
       vmin : -Math.PI,
       vmax : Math.PI,
       vnum : 50,
       name : 'triaxial_hexatorus',
},{
       x : "sin(v/2)* sin(u) + cos(v/2) *sin(2* u)",
       y : "(2 + cos(v/2)* sin(u) - sin(v/2)* sin(2 *u))* cos(v)",
       z : "(2 + cos(v/2)* sin(u) - sin(v/2)* sin(2 *u))* sin(v)",
       umin : 0,
       umax : 2*Math.PI,
       unum : 50,
       vmin : 0,
       vmax : 2*Math.PI,
       vnum : 50,
       name : 'klein_2',
},{
       x : "cos(u+v)/(sqrt(2.)+cos(v-u))",
       y : "sin(v-u)/(sqrt(2.)+cos(v-u))",
       z : "sin(u+v)/(sqrt(2.)+cos(v-u))",
       umin : 0,
       umax : Math.PI,
       unum : 50,
       vmin : 0,
       vmax : 2*Math.PI,
       vnum : 50,
       name : 'cliffordtorus',
},{
       x : "2/3* (cos(u)* cos(2*v) + sqrt(2)* sin(u)* cos(v))* cos(u) / (sqrt(2) - sin(2*u)* sin(3*v))",
       y : "sqrt(2)* cos(u)* cos(u) / (sqrt(2) - sin(2*u)* sin(3*v))",
       z : "2/3* (cos(u)* sin(2*v) - sqrt(2)* sin(u)* sin(v))* cos(u) / (sqrt(2) - sin(2*u)* sin(3*v))",
       umin : 0,
       umax : Math.PI,
       unum : 40,
       vmin : 0,
       vmax : Math.PI,
       vnum : 40,
       name : 'boy',
},{
       x : "(2 + cos(u))*(v/3 - sin(v))",
       y : "(2 + cos(u + 2*PI / 3))*(cos(v) - 1) ",
       z : "(2 + cos(u - 2*PI / 3))*(cos(v) - 1) ",
       umin : -Math.PI,
       umax : Math.PI,
       unum : 40,
       vmin : -2*Math.PI,
       vmax : 2*Math.PI,
       vnum : 40,
       name : 'bent_horns',
},{
       x : "(2 + sin(u) *sin(v)) *sin(3*v/2)",
       y : "cos(u) *sin(v) + 2 *v/PI - 2",
       z : "(2 + sin(u) *sin(v)) *cos(3*v/2)",
       umin : 0,
       umax : 2*Math.PI,
       unum : 50,
       vmin : 0,
       vmax : 2*Math.PI,
       vnum : 50,
       type : 'croissant',
},{
       x : "1/2*sin(2*u)*sin(v)^2",
       y : "1/2*cos(u)*sin(2*v)",
       z : "1/2*sin(u)*cos(2*v)",
       umin : 0,
       umax : Math.PI,
       unum : 50,
       vmin : -Math.PI/2,
       vmax : Math.PI/2,
       vnum : 50,
       name : 'roman',
},{
       x : "(sin(2 * u) * cos(v) * cos(v))",
       y : "(cos(u) * sin(2 * v))",
       z : "(sin(u) * sin(2 * v))",
       umin : -Math.PI/2,
       umax : Math.PI/2,
       unum : 50,
       vmin : -Math.PI/2,
       vmax : Math.PI/2,
       vnum : 50,
       name : 'steiner',
},{
       x : "(sin(u) * sin(2 * v) / 2)",
       y : "(cos(2 * u) * cos(v) * cos(v))",
       z : "(sin(2 * u) * cos(v) * cos(v))",
       umin : -Math.PI/2,
       umax : Math.PI/2,
       unum : 50,
       vmin : -Math.PI/2,
       vmax : Math.PI/2,
       vnum : 50,
       name : 'crosscap',
},{
       x : "cos(u)*(4*sqrt(1-v^2)*sin(abs(u))^abs(u))",
       y : "v",
       z : "sin(u) *(4*sqrt(1-v^2)*sin(abs(u))^abs(u))",
       umin : -Math.PI,
       umax : Math.PI,
       unum : 50,
       vmin : -1,
       vmax : 1,
       vnum : 50,
       name : 'heart',
},]

	class Surface {
  
  
  constructor() {
      var umin = surfaces[surface_num]['umin'];
      var umax = surfaces[surface_num]['umax'];
      var unum = surfaces[surface_num]['unum'];
      var vmin = surfaces[surface_num]['vmin'];
      var vmax = surfaces[surface_num]['vmax'];
      var vnum = surfaces[surface_num]['vnum'];
      var func = surfaces[surface_num]['func'];
      this.x = Parser.parse(surfaces[surface_num]['x']).toJSFunction( ['u','v'] );
      this.y = Parser.parse(surfaces[surface_num]['y']).toJSFunction( ['u','v'] );
      this.z = Parser.parse(surfaces[surface_num]['z']).toJSFunction( ['u','v'] );
      this.coords = (u, v) => new Vector(this.x(u,v), this.y(u,v), this.z(u,v));
		this.vertices = [];
		this.faces = [];
		this.u = [];
		this.v = [];
    let u = iu => umin + (umax-umin)*iu/(unum-1);
    let v = iv => vmin + (vmax-vmin)*iv/(vnum-1);
    let index = (iu, iv) => iu*vnum + iv;
    let push_square = (x1, y1) => {
        let x2 = (x1+1)%unum;
        let y2 = (y1+1)%vnum;
				this.faces.push(index(x1, y1));
				this.faces.push(index(x1, y2));
				this.faces.push(index(x2, y2));
				this.faces.push(index(x1, y1));
				this.faces.push(index(x2, y2));
				this.faces.push(index(x2, y1));
    }
		for (let iu = 0; iu < unum; iu++) {
				for (let iv = 0; iv < vnum; iv++) {
				  this.vertices.push(this.coords( u(iu), v(iv) ));
				  this.u.push(u(iu));
				  this.v.push(v(iv));
					push_square(iu, iv);
				}
				
		}
		
  }
  
  get mesh() {
    return {
			"v": this.vertices,
			"f": this.faces
		};
  }

  color(v) {
 		 let f = $('#colorfunc').html(); 
     return colorfunc (f, this.u[v.index], this.v[v.index]);
  }
}
var s;
  
		if (!Detector.webgl) Detector.addGetWebGLMessage();

		let input = document.getElementById("fileInput");
		let renderer = undefined;
		let camera = undefined;
		let controls = undefined;
		let showNormals = false;
		let useBasicMaterial = false;
		let showWireframe = false;
		let scene = undefined;
		let threeMesh = undefined;
		let threeGeometry = undefined;
		let normalsHelper = undefined;
		let wireframe = undefined;
		let materialSettings = {
			vertexColors: THREE.VertexColors,
			polygonOffset: true,
			polygonOffsetFactor: 1,
			polygonOffsetUnits: 1,
			side: THREE.DoubleSide
		};

		let positions = undefined;
		let uvs = undefined;
		let normals = undefined;
		let colors = undefined;
		let indices = undefined;

		let mesh = undefined;
		let geometry = undefined;


		const ORANGE = new Vector(1.0, 0.5, 0.0);
		let guiFields = {
			"Load Mesh": function() {
				input.click();
			},
			"Export Mesh": function() {
				exportFile(MeshIO.writeOBJ({
					"v": positions,
					"vt": uvs,
					"vn": normals,
					"f": indices
				}));
			},
			"Plot": "Shaded",
			"Normals": "Equally Weighted",
			"Show Normals": showNormals,
			"Show Wireframe": showWireframe
		};

		init();
		animate();

		function init() {
			let container = document.createElement("div");
			container.id="container";
			document.body.appendChild(container);

			initRenderer(container);
			//initGUI();
			initCamera();
			initScene();
			initLights();
			initMesh();
			initControls();
			addEventListeners();
		}

		function initRenderer(container) {
			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setPixelRatio(window.devicePiuelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);
		}

		function initGUI() {
			let gui = new dat.GUI();

			let io = gui.addFolder("IO");
			io.add(guiFields, "Load Mesh");
			io.add(guiFields, "Export Mesh");
			io.open();

			gui.add(guiFields, "Normals", ["Equally Weighted", "Tip Angle Weighted", "Sphere Inscribed",
				"Area Weighted (AN)", "Mean Curvature (HN)", "Gauss Curvature (KN)"
			]).onChange(updateNormals).listen();
			gui.add(guiFields, "Plot", ["Shaded", "A", "H", "K", "κ max", "κ min", "colorfunc"]).onChange(updatePlot).listen();
			gui.add(guiFields, "Show Normals").onChange(toggleNormals).listen();
			gui.add(guiFields, "Show Wireframe").onChange(toggleWireframe).listen();
		}

		window.onload = function() {
			input.addEventListener("change", function(e) {
				let file = input.files[0];
				filename = file.name;

				if (filename.endsWith(".obj")) {
					let reader = new FileReader();
					reader.onload = function(e) {
						initMesh(reader.result);
					}

					reader.onerror = function(e) {
						alert("Unable to load OBJ file");
					}

					reader.readAsText(file);

				} else {
					alert("Please load an OBJ file");
				}
			});
		}

		function exportFile(text) {
			let element = document.createElement("a");
			element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(text));
			element.setAttribute("download", filename);

			element.style.display = "none";
			document.body.appendChild(element);

			element.click();

			document.body.removeChild(element);
		}

		function updateNormals(value) {
			for (let v of mesh.vertices) {
				let i = v.index;

				let normal;
				if (value === "Equally Weighted") normal = geometry.vertexNormalEquallyWeighted(v);
				else if (value === "Tip Angle Weighted") normal = geometry.vertexNormalAngleWeighted(v);
				else if (value === "Sphere Inscribed") normal = geometry.vertexNormalSphereInscribed(v);
				else if (value === "Area Weighted (AN)") normal = geometry.vertexNormalAreaWeighted(v);
				else if (value === "Mean Curvature (HN)") normal = geometry.vertexNormalMeanCurvature(v);
				else if (value === "Gauss Curvature (KN)") normal = geometry.vertexNormalGaussCurvature(v);

				normals[3 * i + 0] = normal.x;
				normals[3 * i + 1] = normal.y;
				normals[3 * i + 2] = normal.z;
			}

			threeGeometry.attributes.normal.needsUpdate = true;
			normalsHelper.update();
		}

		function toggleNormals(checked) {
			showNormals = checked;
			if (showNormals) scene.add(normalsHelper);
			else scene.remove(normalsHelper);
		}

		function updatePlot(value) {
			let max = 0;
			let vertexQuantity = {};
			if (value !== "Shaded") {
				useBasicMaterial = true;
				for (let v of mesh.vertices) {
          if ((value === "colorfunc") || (value === undefined)) {
						vertexQuantity[v] = s.color(v);
					} else if (value === "A") {
						vertexQuantity[v] = geometry.circumcentricDualArea(v);

					} else if (value === "K") {
						vertexQuantity[v] = geometry.scalarGaussCurvature(v);

					} else if (value === "H") {
						vertexQuantity[v] = geometry.scalarMeanCurvature(v);

					} else {
						let area = geometry.barycentricDualArea(v);
						let [k1, k2] = geometry.principalCurvatures(v);
						if (value === "κ min") vertexQuantity[v] = k1 * area;
						else vertexQuantity[v] = k2 * area;
					}

					max = Math.max(Math.abs(vertexQuantity[v]), max);
				}

			} else {
				useBasicMaterial = false;
			}

			max = Math.min(Math.PI / 8, max);

			for (let v of mesh.vertices) {
				let i = v.index;

				let color = value === "Shaded" ? ORANGE : colormap(vertexQuantity[v], -max, max, seismic);
				colors[3 * i + 0] = color.x;
				colors[3 * i + 1] = color.y;
				colors[3 * i + 2] = color.z;
			}

			if (useBasicMaterial) threeMesh.material = new THREE.MeshBasicMaterial(materialSettings);
			else threeMesh.material = new THREE.MeshPhongMaterial(materialSettings);
			threeGeometry.attributes.color.needsUpdate = true;
		}

		function toggleWireframe(checked) {
			showWireframe = checked;
			if (showWireframe) threeMesh.add(wireframe);
			else threeMesh.remove(wireframe);
		}

		function initCamera() {
			const fov = 45.0;
			const aspect = window.innerWidth / window.innerHeight;
			const near = 0.1;
			const far = 1000;
			const eyeZ = 3.5;

			camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
			camera.position.z = eyeZ;
		}

		function initScene() {
			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xffffff);
		}

		function initLights() {
			let ambient = new THREE.AmbientLight(0xffffff, 0.35);
			camera.add(ambient);

			let point = new THREE.PointLight(0xffffff);
			point.position.set(2, 20, 15);
			camera.add(point);

			scene.add(camera);
		}

		function initMesh(text) {
		  if (text == undefined) {
		    s = new Surface();
  			var polygonSoup = s.mesh;
  		}
  		else {
   			var polygonSoup = MeshIO.readOBJ(text);
  		}
			mesh = new Mesh();
			if (mesh.build(polygonSoup)) {
				// remove any previously loaded mesh from scene
				scene.remove(threeMesh);
				scene.remove(normalsHelper);

				// create geometry object
				geometry = new Geometry(mesh, polygonSoup["v"]);

				// create a THREE.js mesh (and geometry) object
				initThreeMesh();
				scene.add(threeMesh);

				updateNormals(guiFields["Normals"]);

				// update metadata
				let element = document.getElementById("meta");
				element.textContent = "Total Angle Defect: " + (geometry.totalAngleDefect() / Math.PI).toFixed(2) + "π";
				element.textContent += "\nEuler Characteristic: " + mesh.eulerCharacteristic();

			} else {
				alert("Unable to build halfedge mesh");
			}
		}

		function initThreeMesh() {
			// create geometry object
			threeGeometry = new THREE.BufferGeometry();

			// fill position, normal and color buffers
			let V = mesh.vertices.length;
			positions = new Float32Array(V * 3);
			normals = new Float32Array(V * 3);
			colors = new Float32Array(V * 3);
			for (let v of mesh.vertices) {
				let i = v.index;

				let position = geometry.positions[v];
				positions[3 * i + 0] = position.x;
				positions[3 * i + 1] = position.y;
				positions[3 * i + 2] = position.z;

				let normal = geometry.vertexNormalEquallyWeighted(v);
				normals[3 * i + 0] = normal.x;
				normals[3 * i + 1] = normal.y;
				normals[3 * i + 2] = normal.z;

				colors[3 * i + 0] = ORANGE.x;
				colors[3 * i + 1] = ORANGE.y;
				colors[3 * i + 2] = ORANGE.z;
			}

			// fill index buffer
			let F = mesh.faces.length;
			indices = new Uint32Array(F * 3);
			for (let f of mesh.faces) {
				let i = 0;
				for (let v of f.adjacentVertices()) {
					indices[3 * f.index + i++] = v.index;
				}
			}

			// set geometry
			threeGeometry.setIndex(new THREE.BufferAttribute(indices, 1));
			threeGeometry.addAttribute("position", new THREE.BufferAttribute(positions, 3));
			threeGeometry.addAttribute("normal", new THREE.BufferAttribute(normals, 3));
			threeGeometry.addAttribute("color", new THREE.BufferAttribute(colors, 3));

			// create material
			let threeMaterial = new THREE.MeshPhongMaterial(materialSettings);

			// create wireframe
			wireframe = new THREE.LineSegments();
			wireframe.geometry = new THREE.WireframeGeometry(threeGeometry);
			wireframe.material = new THREE.LineBasicMaterial({
				color: 0x000000,
				linewidth: 0.75
			});

			// create mesh
			threeMesh = new THREE.Mesh(threeGeometry, threeMaterial);

			// create normals helper
			normalsHelper = new THREE.VertexNormalsHelper(threeMesh, 0.02, 0x0000ff, 0.75);

			// toggle normals, curvature and wireframe
			toggleNormals(showNormals);
			updatePlot(guiFields["Plot"]);
			toggleWireframe(showWireframe);
		}

		function initControls() {
			controls = new THREE.TrackballControls(camera, renderer.domElement);
			controls.rotateSpeed = 5.0;
		}

		function addEventListeners() {
			window.addEventListener("resize", onWindowResize, false);
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatriu();

			renderer.setSize(window.innerWidth, window.innerHeight);
			controls.handleResize();
			render();
		}

		function animate() {
			requestAnimationFrame(animate);
			controls.update();
			render();
		}

		function render() {
			renderer.render(scene, camera);
		}
	</script>
</body>

</html>
